<!--
    Copyright Â© 2016-2016 Inria.  All rights reserved.
    $COPYRIGHT$

    Additional copyrights may follow
    See COPYING in top-level directory.

    $HEADER$
 --!>

<!doctype html>
<html>
<head>
    <script type="text/javascript" src="visdist/vis.js"></script>
    <link href="visdist/vis.css" rel="stylesheet" type="text/css"/>

    <style type="text/css">
        #mynetwork {
            width: auto;
            height: 800px;
            border: 1px solid lightgray;
        }
    </style>

    <title>Network topology</title>
    <input type="file" id="files" name="files[]" multiple />
    <select id="selectPartition" onchange="draw()" selected="true">
        <option value="" disabled=true>Choose a partition</option>
    </select>
    <select id="selectColors" onchange="nodeColors()" selected="true">
        <option value="" disabled=true>Choose a color mode</option>
    </select>
    <input id="reload" type="button" value="Reload" onclick="draw();" />
    <input id="searchValue" type="text" name="searchValue"
                                        onkeydown="if (event.keyCode == 13) search();"/>
    <select id="selectSearch" selected="true">
        <option value="" disabled=true>Choose a search field</option>
        <option value="hostname"      >Hostname</option>
        <option value="id"            >Id</option>
        <option value="type"          >Type</option>
    </select>
    <input id="search" type="button" value="Search" onclick="search();" />


</head>
<body>

<div id="mynetwork"></div>
<pre id="eventSpan"></pre>

<script type="text/javascript">
  var edges;
  var nodes;
  var shownEdges;
  var shownEdes;
  var partitions;
  var mydata;
  var topos;
  var switchColor = {border: "grey", background: "grey"};
  var hostColor =  {border: "red", background: "red"};
  var hostColors;
  var nodesWithPhysics;
  var edgesWithPhysics;
  var bandwidthList;
  var network;

  function handleFileSelect(evt) {
    var files = evt.target.files;

    // Loop through the file list
    for (var i = 0, f; f = files[i]; i++) {

        var fr = new FileReader();
        fr.onload = function(e) {
            data = e.target.result
            loadFile(data);
        };
        fr.readAsText(f);

    }
  }

  document.getElementById('files').addEventListener('change', handleFileSelect, false);

  function renameKey(obj, newkey, oldkey)
  {
      return obj.map(function(d) { d[newkey] = d[oldkey]; delete d[oldkey]; return d; });
  }

  function palette(size) {
      var palette = [];

      if (!size)
          return ["red"];

      if (size <= 9)
          return ["blue", "orange", "green", "pink", "brown", "purple",
              "yellow", "red", "gray"].slice(0, size+1);

      if (size <= 11)
          return ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99",
              "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a",
              "#ffff99"].slice(0, size+1);

      var v = Math.ceil(Math.pow(size+1, 1/3));
      var value = 255/v;
      for( var rStep = 0, r = 0; rStep < v; rStep++) {
          for( var gStep = 0, g = 0; gStep < v; gStep++ ) {
              for( var bStep = 0, b = 0; bStep < v; bStep++ ) {
                  if (!r && !g && !b)
                      continue;
                  palette.push('rgb(' + Math.round(r) + ', ' + Math.round(g) + ', '
                              +  Math.round(b) + ')');
                  b += value;
              }
              g += value;
          }
          r += value;
      }
      return palette;
  }

  function loadFile(data)
  {
      mydata = JSON.parse(data);
      partitions = mydata.partitions;
      topos = mydata.hwloctopos;


      /* Add elements to selectColors */
      var selectColors = document.getElementById("selectColors");
      while (selectColors.length > 1) {
          selectColors.removeChild(selectColors.lastChild);
      }
      {
        var el = document.createElement("option");
        el.textContent = "normal";
        el.value = "normal";
        selectColors.appendChild(el);
      }
      if (partitions.length) {
        var el = document.createElement("option");
        el.textContent = "partition";
        el.value = "partition";
        selectColors.appendChild(el);
      }
      if (topos.length) {
        var el = document.createElement("option");
        el.textContent = "hwloc";
        el.value = "hwloc";
        selectColors.appendChild(el);
      }
      {
        var el = document.createElement("option");
        el.textContent = "bandwidth";
        el.value = "bandwidth";
        selectColors.appendChild(el);
      }

      /* Add elements to selectPartition */
      var selectPartition = document.getElementById("selectPartition");
      while (selectPartition.length > 1) {
          selectPartition.removeChild(selectPartition.lastChild);
      }
      var partitionOptions = partitions.slice();
      partitionOptions.unshift("All");
      for(var i = 0; i < partitionOptions.length; i++) {
          var partition = partitionOptions [i];
          var el = document.createElement("option");
          el.textContent = partition;
          el.value = i-1; // because of "All"
          selectPartition.appendChild(el);
      }

      mydata.edges.map(
              function(e) {e["label"] = Math.round(parseFloat(e["gbits"]));});
      var gbits_min = Math.min.apply(null, mydata.edges.map(function(e) { return e["gbits"];}));
      mydata.edges.map(
              function(e) {e["width"] = e["gbits"]/gbits_min;});
      mydata.edges = renameKey(mydata.edges, "from", "src");
      mydata.edges = renameKey(mydata.edges, "to", "dst");
      edges = new vis.DataSet({});
      edges.add(mydata.edges);


      mydata.nodes = renameKey(mydata.nodes, "level", "lv");
      mydata.nodes = renameKey(mydata.nodes, "title", "desc");
      mydata.nodes.map(function(n)
              { n["color"] = n["type"] == "host" ? hostColor: switchColor; });
      mydata.nodes.map(function(n) {
          n["bandwidth"] =
              edges.get(n["edges"]).map(function(e) { return e.gbits; })
              .reduce(function(a, b) { return a + b; }, 0);
      });
      mydata.nodes.map(function(n) {
          n["size"] = 10*Math.log(n["bandwidth"]);
      });
      nodes = new vis.DataSet({});
      nodes.add(mydata.nodes);

      bandwidthList = [];
      /* Build list of sizes */
      nodes.forEach(function(n) {
          if (bandwidthList.indexOf(n.size) == -1) {
              bandwidthList.push(n.size);
          }
      });
  }

  function nodeColors()
  {
    var e = document.getElementById("selectColors");
    var colorMode = e.options[e.selectedIndex].value;

    if (colorMode == "normal") {
        color = hostColor;
        shownNodes.forEach(function(n) {
            if (n.type == "host") {
                shownNodes.update({id: n.id, color: color});
            }
        });
    }
    else if (colorMode == "partition") {
        var colors = palette(partitions.length);
        shownNodes.forEach(function(n) {
            if (n.type == "host") {
                var colorIdx = n.part[0];
                shownNodes.update({id: n.id, color: colors[colorIdx]});
            }
        });
    }
    else if (colorMode == "hwloc") {
        var colors = palette(topos.length);
        shownNodes.forEach(function(n) {
            if (n.type == "host") {
                var colorIdx = n.topo;
                if (colorIdx != -1) {
                    shownNodes.update({id: n.id, color: colors[colorIdx]});
                }
            }
        });
    }
    else if (colorMode == "bandwidth") {
        var colors = palette(bandwidthList.length);
        shownNodes.forEach(function(n) {
            var colorIdx = bandwidthList.indexOf(n.size);
            if (colorIdx != -1) {
                shownNodes.update({id: n.id, color: colors[colorIdx]});
            }
        });
    }
  }

  function selectNodes(field, value)
  {
      var nodeIds;
      var regexp = new RegExp(value, "g");

      var nodeSet = shownNodes.get({filter: function(n) {
          return n[field] ? n[field].toString().match(regexp): false;
      }});
      nodeIds = nodeSet.map(function(n) { return n.id; });

      if (nodeIds) {
          network.selectNodes(nodeIds);
          showNodeInfo(nodeIds);
      }
  }

  function showNodeInfo(nodeIds)
  {
      var html = "";
      var n = 0;
      var inputNodes = nodes.get(nodeIds);
      while (n < inputNodes.length) {
          var node = inputNodes[n];
          var nodeEdges = node.edges;

          var neighbours = [];
          var i = 0;

          while (i < nodeEdges.length)
          {
              var edge = edges.get(nodeEdges[i]);
              var dest = nodes.get(edge.to);
              var s = '\t' + dest.title + ' (edgeId ' + nodeEdges[i] + ' ports '
                      + edge.src_port + '->' + edge.dst_port + '): ';
              s += edge.label + 'Gb\n';
              i++;
              neighbours .push(s);
          }

          html +=
              '<h2>' + node.title + '</h2>' +
              'ID: ' + node.id + '\n' +
              'Partitions: ' + node.part.map(function(p){return partitions[p]})
              .join(', ') + '\n' +
              neighbours.length + ' neighbours:\n' + neighbours.sort().join('') +
              'Total bandwidth: ' + node.bandwidth + '\n' +
              ((node.topo != -1) ? ('Hwloc topology: ' + topos[node.topo]): '');
          n++;
      }
      document.getElementById('eventSpan').innerHTML = html;
  }

  function search()
  {
    var selectSearch = document.getElementById("selectSearch");
    var field = selectSearch.options[selectSearch.selectedIndex].value;

    if (field == "") {
    }
    else {
        var searchValue = document.getElementById("searchValue");
        var value = searchValue.value;
        selectNodes(field, value);
    }
  }

  function draw()
  {
    var selectPartition = document.getElementById("selectPartition");
    var partition = parseInt(
        selectPartition.options[selectPartition.selectedIndex].value);

    if (partition == -1) { // for "All"
        // TODO improve
        subEdges = new vis.DataSet(edges.get());
        shownNodes = new vis.DataSet(nodes.get());
    }
    else {
        subEdges = new vis.DataSet(edges.get({filter: function (e) {
            return (e.part.indexOf(partition) > -1);
        }}));
        shownNodes = new vis.DataSet(nodes.get({filter: function (e) {
            return (e.part.indexOf(partition) > -1);
        }}));
    }

    if (1 || partition != "All")
        shownEdges = subEdges;
    else
        /* FIXME does not work if we select a partition and logical path in not the
           same in the other way and neither when we move nodes */
        /* we draw half of the edges (only one way) */
        shownEdges = new vis.DataSet(subEdges.get({filter: function (e) {
            return (e.from < e.to);
        }}));

    var selectColor = document.getElementById("selectColors");
    var colorMode =
        selectColor.options[selectColor.selectedIndex].value;
    if (colorMode != "")
        nodeColors();
    else
        selectColor.selectedIndex = 1;

    // create a network
    var container = document.getElementById('mynetwork');
    var data = {
        nodes: shownNodes,
        edges: shownEdges
    };

    var options = {interaction:{hover:true, tooltipDelay:0},
                   physics: {barnesHut: {gravitationalConstant:-15000,
                                         }},
                   nodes: {shape: 'dot'},
                   edges: {color: {inherit: true}}
    };
    network = new vis.Network(container, data, options);

    network.on("selectNode", function (params) {
        params.event = "[original event]";
        showNodeInfo(params.nodes);
    });
    network.on("deselectNode", function (params) {
        document.getElementById('eventSpan').innerHTML = '';
    });

    network.on("selectEdge", function (params) {
        params.event = "[original event]";
        var edge = edges.get(params.edges[0]);

        document.getElementById('eventSpan').innerHTML =
            '<h2>' + nodes.get(edge.from).title + ' -> ' + nodes.get(edge.to).title + '</h2>' +
            'ID: ' + edge.id + '\n' +
            'From: ' + edge.from + '\n' +
            'To: ' + edge.to + '\n' +
            'Partitions: ' + edge.part.map(function(p){return partitions[p]})
                                      .join(', ') + '\n';
    });
    network.on("deselectEdge", function (params) {
        document.getElementById('eventSpan').innerHTML = '';
    });

    network.on("dragStart", function (params) {
        params.event = "[original event]";
        var nodeIds = params.nodes;
        var edgeIds = params.edges;

        nodesWithPhysics = [];
        edgesWithPhysics = edgeIds;
        for (var e = 0; e < edgeIds.length; e++) {
            var edgeId = edgeIds[e];
            shownEdges.update({id: edgeId, physics: true});

            var edge = shownEdges.get(edgeId);
            var node = shownNodes.get(edge.to);
            if (node.edges.length <= 1) {
                nodesWithPhysics.push(edge.to);
                shownNodes.update({id: edge.to, physics: true});
            }
        }
    });
    network.on("dragEnd", function (params) {
        for (var e = 0; e < edgesWithPhysics.length; e++) {
            shownEdges.update({id: edgesWithPhysics[e], physics: false});
        }
        for (var n = 0; n < nodesWithPhysics.length; n++) {
            shownNodes.update({id: nodesWithPhysics[n], physics: false});
        }
    });

    network.on("stabilizationIterationsDone", function () {
        network.setOptions({nodes:{physics:false},
                            edges:{physics:false},
        });
    });
  }


</script>

</body>
</html>
